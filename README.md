# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering
**QUESTION ONE**
Explain what software engineering is and discuss its importance in the technology industry.

Software engineering is the disciplined approach to designing, developing, testing, and maintaining software systems. It applies engineering principles to ensure software is reliable, scalable, and meets user needs. In the technology industry, its importance lies in producing high-quality software that performs well, remains stable, and can adapt to future changes. This ensures efficient and effective technological solutions and drives innovation.


**QUESTION TWO**
Identify and describe at least three key milestones in the evolution of software engineering.

a)1950s - Early Programming Languages: The creation of programming languages like FORTRAN and COBOL made coding easier and more organized, setting the stage for structured software development.

b)1968 - Software Engineering Conference: The NATO conference introduced the term "software engineering" and stressed the need for better methods to manage software projects, leading to more formal development practices.

c)1991 - Agile Manifesto: Agile methods promoted flexible, iterative development and teamwork, changing how software is developed by focusing on quick improvements and adapting to changes.

**QUESTION THREE**
List and briefly explain the phases of the Software Development Life Cycle.

Requirement Analysis: Identify and document what the software needs to do.
Planning: Develop a project plan outlining scope, timeline, and resources.
Design: Create the software’s architecture and detailed design.
Implementation: Write and develop the actual code.
Testing: Verify the software works correctly and fix any bugs.
Deployment: Release the software to users and provide necessary support.
Maintenance: Update and fix the software as needed over time.

**QUESTION FOUR**
Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
A)Waterfall is best for projects with fixed requirements and a clear path, providing predictability but lacking flexibility.
Example: A government contract for a specific application where requirements are fixed and any changes could lead to delays or additional costs.

B)Agile is suited for projects with evolving requirements and a need for adaptability, emphasizing iterative development and collaboration.
Example: Developing a mobile app where user feedback and market trends might influence feature changes and updates throughout the development process.
**COMPARISON**
Process: Waterfall is linear and sequential; Agile is iterative and cyclical.
Requirements: Waterfall has fixed requirements; Agile adapts to changes.
Flexibility: Waterfall is rigid; Agile is flexible.
Project Phases: Waterfall has distinct phases; Agile’s phases overlap and are revisited.
Customer Involvement: Waterfall gathers feedback at the end; Agile seeks continuous feedback.
Documentation: Waterfall requires extensive documentation; Agile focuses on working software.
Testing: Waterfall tests after development; Agile tests continuously.
Risk Management: Waterfall manages risks late; Agile addresses risks continuously.
Delivery: Waterfall delivers a final product; Agile offers frequent releases.
Best for:Waterfall: Projects with fixed requirements, like regulatory systems.
             Agile: Projects with evolving requirements, like software development.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
